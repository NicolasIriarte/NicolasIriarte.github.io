[{"authors":[],"categories":[],"content":"Aquí podrá encontrar de manera organizada todos los blogs publicados de manera jerárquica. Sientase libre de explorar la barra lateral izquierda.\nSi encuentra algun error, o tiene alguna sugerencia de post. Sientase libre de abrir un issue en el repositorio del blog.\n","date":"July 29, 2023","img":"","lang":"es","langName":"Español","largeImg":"","permalink":"/es/docs/introduction/","series":[{"title":"Guide","url":"/es/series/guide/"}],"smallImg":"","tags":[],"timestamp":1690588800,"title":"Introducción"},{"authors":[],"categories":[],"content":"Here you can find in an organized way all the blogs published in a hierarchical way. Feel free to explore the left sidebar.\nIf you find any errors, or have any post suggestions. Feel free to open a repository issue tracking of the blog.\n","date":"July 29, 2023","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/introduction/","series":[{"title":"Guide","url":"/series/guide/"}],"smallImg":"","tags":[],"timestamp":1690588800,"title":"Introduction"},{"authors":[],"categories":[],"content":"¡Bienvenido a Bytewise!\n¡Hola! Soy Nicolás Iriarte, un apasionado desarrollador de software y un entusiasta estudiante de la Maestría en Sistemas Embebidos. Actualmente, estoy encantado de ser parte de la industria aeroespacial, trabajando como ingeniero de software para INVAP, donde nos dedicamos a desarrollar software de vanguardia para naves espaciales.\nAcerca de mí:\nActualmente me desenvuelvo como Technical Leader en la industria aeroespacial para INVAP. También me encuentro estudiando una Especialización en Sistemas Embebidos, donde he estado aprendiendo sobre Bare Metal (STM32 NUCLEO-F429ZI) y Arquitectura de Procesadores (ARM Cortex-M4).\nEn este momento, estoy trabajando en mi proyecto de grado titulado: \u0026ldquo;Emulador de microprocesador Leon3 para desarrollo de software satelital y simuladores\u0026rdquo;. En este proyecto, estoy desarrollando un emulador del microprocesador Leon3 (GR712RC - Gaisler) utilizando el framework para herramientas de compilación de LLVM. El desarrollo se está realizando en C++20, y tiene la intención de que el emulador desarrollado pueda ser utilizado en ambientes de simulación tal como SMP2 o similares.\nMis intereses y habilidades son:\nFluidez en C/C++. Python y Lua en menor medida. Programación en C para sistemas embebidos. Desarrollo contínuo. (CI/CD). Inglés. Por qué este blog:\nA través de este blog, pretendo compartir mis experiencias, ideas y conocimientos en el mundo del desarrollo de software y sistemas integrados. Creo que compartir conocimientos no solo ayuda a los demás, sino que también me permite crecer como desarrollador y como persona.\nQue esperar:\nEn este blog, puede esperar una variedad de temas relacionados con el desarrollo de software, consejos y trucos de programación, debates en profundidad sobre C/C++ y Lua, y conocimientos sobre el apasionante ámbito de los sistemas integrados. ¡Desde tutoriales hasta proyectos de la vida real, lo cubriré todo!\nÚnete a mí en este viaje:\nEstoy ansioso por conectarme con desarrolladores, estudiantes y entusiastas de ideas afines que comparten una pasión por la tecnología y la programación. Aprendamos unos de otros, intercambiemos ideas y fomentemos una comunidad de apoyo que prospere con la curiosidad y la innovación.\nPonerse en contacto:\nNo dude en comunicarse conmigo a través de la sección de comentarios en cada publicación del blog o a través de mis canales de redes sociales. Estoy emocionado de interactuar con mis lectores y responder cualquier pregunta que pueda tener.\n¡Gracias por detenerte! Emprendamos juntos esta emocionante aventura.\n¡Feliz codificación! Nicolás Iriarte\n","date":"January 1, 1","img":"","lang":"es","langName":"Español","largeImg":"","permalink":"/es/about/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"About"},{"authors":[],"categories":[],"content":"Welcome to Bytewise!\nHey there! I\u0026rsquo;m Nicolás Iriarte, a passionate software developer and an enthusiastic student pursuing a Master\u0026rsquo;s degree in Embedded Systems. Currently, I\u0026rsquo;m thrilled to be part of the aerospace industry, working as a software engineer for INVAP, where we\u0026rsquo;re dedicated to developing cutting-edge software for spacecraft.\nAbout Me:\nCurrently I’m working as Technical Leader in the aerospace industry for INVAP. I\u0026rsquo;m also pursuing a Master\u0026rsquo;s in Embedded Systems, where I have been learning about Bare Metal (STM32 NUCLEO-F429ZI) and Processor Architecture (ARM Cortex-M4).\nRight now, I\u0026rsquo;m working on my degree project titled: \u0026ldquo;Leon3 Microprocessor Emulator for Satellite Software Development and Simulators\u0026rdquo;. In this project, I am developing an emulator for the Leon3 (GR712RC - Gaisler) microprocessor using the LLVM build tools framework. The development is being done in C++20, and it is intended that the developed emulator can be used in simulation environments such as SMP2 or similar.\nMy interests and skills are:\nFluency in C/C++. Python and Lua to a lesser extent. Programming in C for embedded systems. Continuous development. (CI/CD). English. Why This Blog:\nThrough this blog, I aim to share my experiences, insights, and knowledge in the world of software development and embedded systems. I believe that sharing knowledge not only helps others but also allows me to grow both as a developer and as an individual.\nWhat to Expect:\nOn this blog, you can look forward to a variety of topics related to software development, programming tips and tricks, in-depth discussions on C/C++ and Lua, and insights into the exciting realm of embedded systems. From tutorials to real-life projects, I\u0026rsquo;ll be covering it all!\nJoin Me on this Journey:\nI am eager to connect with like-minded developers, students, and enthusiasts who share a passion for technology and programming. Let\u0026rsquo;s learn from each other, exchange ideas, and foster a supportive community that thrives on curiosity and innovation.\nGet in Touch:\nFeel free to reach out to me via the comments section on each blog post or through my social media channels. I\u0026rsquo;m excited to engage with my readers and answer any questions you might have.\nThank you for stopping by! Let\u0026rsquo;s embark on this exciting adventure together.\nHappy coding! Nicolás Iriarte\n","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/about/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"About"},{"authors":[],"categories":[{"title":"C++ programming","url":"/es/categories/c++-programming/"}],"content":" En C++ constructores son un tipo de método especial de una clase, utilizado para inicializar dicha clase. En caso de que la clase no posea dicho método, el compilador normalmente dará uno por defecto, excepto en los siguientes casos:\nQue explicitamente se programe lo contrario. Que exista algun atributo en la clase que no sea construible por defecto. Que exista al menos otro constructor en la clase. El constructor de la clase se identifica ya que es un método in valor de retorno, y que tiene exactamente el mismo nombre que la clase.\nPor ejemplo:\nstruct Person { Person(std::string name, std::string last_name); }; En este ejemplo, se define la estructura Person, dicha estructura tiene un unico constructor, el cual recive dos argumentos del tipo std::string. Cabe aclarar que al definir un constructor para nuestra estructura, hemos eliminado el que nuestro compilador nos dá por defecto.\nLa implementación de nuestro constructor consta de dos partes:\nUna lista de inicialización, la cual es utilizada para asignar valor a atributos de la clase durante su creación, dicho código es ejecutado cuando la clase es creada. Implementación del constructor, generalmente utilizado para realizar validación de datos, o alguna lógica especial que se necesite realizar al crear nuevas instancias de dicho objeto. struct Person { Person(std::string name, std::string last_name) : // Comienzo de la lista de inicialización. name_(name), last_name_(last_name) { if (name.size() \u0026lt; 3) { throw std::runtime_error(\u0026#34;Nombre demasiado corto\u0026#34;); } } private: std::string name_; std::string last_name_; }; En el ejemplo provisto, utilizamos la lista de inicialización para asignar el nombre y apellido de la persona en la creación del objeto. Y dentro de la lógica del constructor, validamos que el nombre ingresado no sea menor de tres caracteres.\nCabe destacar que, aunque no se trate de un ejemplo muy realista o de uso cotidiano, refleja el funcionamiento y utilidad de un constructor.\n","date":"January 1, 1","img":"","lang":"es","langName":"Español","largeImg":"","permalink":"/es/docs/cpp/constructors/","series":[{"title":"C++","url":"/es/series/c++/"}],"smallImg":"","tags":[{"title":"C++","url":"/es/tags/c++/"},{"title":"Computer science","url":"/es/tags/computer-science/"},{"title":"Easy","url":"/es/tags/easy/"},{"title":"Basic knowledge","url":"/es/tags/basic-knowledge/"}],"timestamp":-62135596800,"title":"Constructores"},{"authors":[],"categories":[{"title":"C++ programming","url":"/categories/c++-programming/"}],"content":" In C++, constructors are a type of special method in a class, used to initialize that class. If the class does not have such a method, the compiler will usually provide a default one, except in the following cases:\nWhen it is explicitly programmed otherwise. When there is an attribute in the class that cannot be default-constructed. When there is at least one other constructor in the class. The class constructor is identified as a method without a return value and has exactly the same name as the class.\nFor example:\nstruct Person { Person(std::string name, std::string last_name); }; In this example, the Person struct is defined, and it has a single constructor that takes two arguments of type std::string. It\u0026#39;s important to note that by defining a constructor for our struct, we have overridden the default constructor provided by the compiler.\nThe implementation of our constructor consists of two parts:\nAn initialization list, which is used to assign values to class attributes during its creation. This code is executed when the class is being created. Implementation of the constructor itself, generally used to perform data validation or any special logic needed when creating new instances of the object. struct Person { Person(std::string name, std::string last_name) : // Start of the initialization list. name_(name), last_name_(last_name) { if (name.size() \u0026lt; 3) { throw std::runtime_error(\u0026#34;Name is too short\u0026#34;); } } private: std::string name_; std::string last_name_; }; In the provided example, we use the initialization list to assign the name and last name of the person during the object\u0026#39;s creation. And within the constructor\u0026#39;s logic, we validate that the entered name is not less than three characters long.\nIt\u0026#39;s worth noting that although this might not be a very realistic or everyday-use example, it reflects the functioning and usefulness of a constructor.\n","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/cpp/constructors/","series":[{"title":"C++","url":"/series/c++/"}],"smallImg":"","tags":[{"title":"C++","url":"/tags/c++/"},{"title":"Computer science","url":"/tags/computer-science/"},{"title":"Easy","url":"/tags/easy/"},{"title":"Basic knowledge","url":"/tags/basic-knowledge/"}],"timestamp":-62135596800,"title":"Constructors"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/contact/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Contact Me"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"es","langName":"Español","largeImg":"","permalink":"/es/contact/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Contactar"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"es","langName":"Español","largeImg":"","permalink":"/es/offline/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/offline/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Offline"},{"authors":[],"categories":[{"title":"C++ programming","url":"/es/categories/c++-programming/"}],"content":" RAII del inglés \u0026#34;Resource Acquisition Is Initialization\u0026#34; es una técnica de C++ para manejar el ciclo de vida de recursos típicamente limitados (memoria en el heap, descriptores de archivos, hilos de ejecución, etc).\nDicha técnica consiste en reservar el recurso durante el constructor del objeto, y su liberación en el destructor. Por ejemplo, imaginemos que se desea modelar una memoria Flash de tamaño variable, para ello, una posibilidad sería la de reservar memoria del heap en su construcción, para liberarla durante su destrucción:\nstruct FlashMemory { FlashMemory(uint32_t size) { memory_ = new uint8_t[size]; } ~FlashMemory() { delete[] memory_; } private: uint8_t *memory_; }; RAII garantiza que mientras el objeto esté instanciado, el recurso será accesible, y define un ciclo de vida del mismo acoplado al ciclo de vida del objeto que lo contiene. Esto facilita su manejo manual y libera al desarrollador que lo utilice de asignaciones manuales de memoria o del recurso.\nEs conveniente que el objeto que maneje al recurso, en nuestro caso FlashMemory tenga métodos expuestos para accederlo, por ejemplo, en nuestro caso, métodos para leer/escribir la memoria.\nstruct FlashMemory { FlashMemory(uint32_t size) : size_(size) { memory_ = new uint8_t[size]; } ~FlashMemory() { delete[] memory_; } /** ,* Lee un Byte de memoria, si se trata de acceder fuera de la memoria se ,* arroja una excepción. ,*/ uint8_t ReadByte(uint32_t position) const { if (position \u0026gt;= size_) { throw std::runtime_error(\u0026#34;Invalid position to Read!\u0026#34;); } return memory_[position]; } /** ,* Escribe un Byte de memoria, si se trata de acceder fuera de la memoria se ,* arroja una excepción. ,*/ void WriteByte(uint32_t position, uint8_t value) { if (position \u0026gt;= size_) { throw std::runtime_error(\u0026#34;Invalid position to Write!\u0026#34;); } memory_[position] = value; } private: uint8_t *memory_; uint32_t size_; }; De esta manera se puede manejar al objeto y su tiempo de vida de manera transparente para el usuario.\nstatic constexpr uint32_t MEMORY_SIZE = 256 * 1024; int main(int argc, char *argv[]) { // Esta linea reserva de manera invisible al usuario memoria en el heap. FlashMemory flash(MEMORY_SIZE); // En el byte 0x64 ponemos el valor 0x23 flash.WriteByte(0x64, 0x23); std::cout \u0026lt;\u0026lt; \u0026#34;La posición 0x64 contiene el valor: \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(flash.ReadByte(0x64)) \u0026lt;\u0026lt; std::endl; return 0; // En este punto el destructor de `FlashMemory` es llamado, y todos // sus recursos liberados de manera automatica. } ","date":"January 1, 1","img":"","lang":"es","langName":"Español","largeImg":"","permalink":"/es/docs/cpp/raii/","series":[{"title":"C++","url":"/es/series/c++/"}],"smallImg":"","tags":[{"title":"C++","url":"/es/tags/c++/"},{"title":"Computer science","url":"/es/tags/computer-science/"},{"title":"Easy","url":"/es/tags/easy/"},{"title":"Basic knowledge","url":"/es/tags/basic-knowledge/"}],"timestamp":-62135596800,"title":"RAII"},{"authors":[],"categories":[{"title":"C++ programming","url":"/categories/c++-programming/"}],"content":" RAII, which stands for \u0026#34;Resource Acquisition Is Initialization,\u0026#34; is a C++ technique for managing the lifecycle of typically limited resources (such as heap memory, file descriptors, threads, etc.).\nThis technique involves reserving the resource during the object\u0026#39;s constructor and releasing it in the destructor. For example, let\u0026#39;s imagine you want to model a variable-sized Flash memory. One possibility would be to allocate memory from the heap during its construction and free it during its destruction:\nstruct FlashMemory { FlashMemory(uint32_t size) { memory_ = new uint8_t[size]; } ~FlashMemory() { delete[] memory_; } private: uint8_t *memory_; }; RAII guarantees that as long as the object is instantiated, the resource will be accessible, and it defines a lifecycle for the resource that is tied to the lifecycle of the containing object. This simplifies manual management and relieves the developer from manual memory allocations or resource handling.\nIt\u0026#39;s advisable for the object that manages the resource, in this case FlashMemory, to have exposed methods for accessing it. For instance, in our case, methods to read/write the memory:\nstruct FlashMemory { FlashMemory(uint32_t size) : size_(size) { memory_ = new uint8_t[size]; } ~FlashMemory() { delete[] memory_; } /** ,* Reads a byte from memory. Throws an exception if an invalid position is ,* accessed. ,*/ uint8_t ReadByte(uint32_t position) const { if (position \u0026gt;= size_) { throw std::runtime_error(\u0026#34;Invalid position to Read!\u0026#34;); } return memory_[position]; } /** ,* Writes a byte to memory. Throws an exception if an invalid position is ,* accessed. ,*/ void WriteByte(uint32_t position, uint8_t value) { if (position \u0026gt;= size_) { throw std::runtime_error(\u0026#34;Invalid position to Write!\u0026#34;); } memory_[position] = value; } private: uint8_t *memory_; uint32_t size_; }; This way, the object and its lifetime can be managed transparently for the user.\nstatic constexpr uint32_t MEMORY_SIZE = 256 * 1024; int main(int argc, char *argv[]) { // This line invisibly allocates memory on the heap for the user. FlashMemory flash(MEMORY_SIZE); // Set the value 0x23 at byte 0x64 flash.WriteByte(0x64, 0x23); std::cout \u0026lt;\u0026lt; \u0026#34;The value at position 0x64 is: \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(flash.ReadByte(0x64)) \u0026lt;\u0026lt; std::endl; return 0; // At this point, the destructor of `FlashMemory` is called, and all // its resources are automatically freed. } ","date":"January 1, 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/cpp/raii/","series":[{"title":"C++","url":"/series/c++/"}],"smallImg":"","tags":[{"title":"C++","url":"/tags/c++/"},{"title":"Computer science","url":"/tags/computer-science/"},{"title":"Easy","url":"/tags/easy/"},{"title":"Basic knowledge","url":"/tags/basic-knowledge/"}],"timestamp":-62135596800,"title":"RAII"}]
