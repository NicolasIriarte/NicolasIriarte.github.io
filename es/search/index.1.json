[{"authors":[],"categories":[],"content":"Aquí podrá encontrar de manera organizada todos los blogs publicados de manera jerárquica. Sientase libre de explorar la barra lateral izquierda.\nSi encuentra algun error, o tiene alguna sugerencia de post. Sientase libre de abrir un issue en el repositorio del blog.\n","date":"29 de julio de 2023","img":"","lang":"es","langName":"Español","largeImg":"","permalink":"/es/docs/introduction/","series":[{"title":"Guide","url":"/es/series/guide/"}],"smallImg":"","tags":[],"timestamp":1690588800,"title":"Introducción"},{"authors":[],"categories":[],"content":"Here you can find in an organized way all the blogs published in a hierarchical way. Feel free to explore the left sidebar.\nIf you find any errors, or have any post suggestions. Feel free to open a repository issue tracking of the blog.\n","date":"29 de julio de 2023","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/introduction/","series":[{"title":"Guide","url":"/series/guide/"}],"smallImg":"","tags":[],"timestamp":1690588800,"title":"Introduction"},{"authors":[],"categories":[],"content":"¡Bienvenido a Bytewise!\n¡Hola! Soy Nicolás Iriarte, un apasionado desarrollador de software y un entusiasta estudiante de la Maestría en Sistemas Embebidos. Actualmente, estoy encantado de ser parte de la industria aeroespacial, trabajando como ingeniero de software para INVAP, donde nos dedicamos a desarrollar software de vanguardia para naves espaciales.\nAcerca de mí:\nActualmente me desenvuelvo como Technical Leader en la industria aeroespacial para INVAP. También me encuentro estudiando una Especialización en Sistemas Embebidos, donde he estado aprendiendo sobre Bare Metal (STM32 NUCLEO-F429ZI) y Arquitectura de Procesadores (ARM Cortex-M4).\nEn este momento, estoy trabajando en mi proyecto de grado titulado: \u0026ldquo;Emulador de microprocesador Leon3 para desarrollo de software satelital y simuladores\u0026rdquo;. En este proyecto, estoy desarrollando un emulador del microprocesador Leon3 (GR712RC - Gaisler) utilizando el framework para herramientas de compilación de LLVM. El desarrollo se está realizando en C++20, y tiene la intención de que el emulador desarrollado pueda ser utilizado en ambientes de simulación tal como SMP2 o similares.\nMis intereses y habilidades son:\nFluidez en C/C++. Python y Lua en menor medida. Programación en C para sistemas embebidos. Desarrollo contínuo. (CI/CD). Inglés. Por qué este blog:\nA través de este blog, pretendo compartir mis experiencias, ideas y conocimientos en el mundo del desarrollo de software y sistemas integrados. Creo que compartir conocimientos no solo ayuda a los demás, sino que también me permite crecer como desarrollador y como persona.\nQue esperar:\nEn este blog, puede esperar una variedad de temas relacionados con el desarrollo de software, consejos y trucos de programación, debates en profundidad sobre C/C++ y Lua, y conocimientos sobre el apasionante ámbito de los sistemas integrados. ¡Desde tutoriales hasta proyectos de la vida real, lo cubriré todo!\nÚnete a mí en este viaje:\nEstoy ansioso por conectarme con desarrolladores, estudiantes y entusiastas de ideas afines que comparten una pasión por la tecnología y la programación. Aprendamos unos de otros, intercambiemos ideas y fomentemos una comunidad de apoyo que prospere con la curiosidad y la innovación.\nPonerse en contacto:\nNo dude en comunicarse conmigo a través de la sección de comentarios en cada publicación del blog o a través de mis canales de redes sociales. Estoy emocionado de interactuar con mis lectores y responder cualquier pregunta que pueda tener.\n¡Gracias por detenerte! Emprendamos juntos esta emocionante aventura.\n¡Feliz codificación! Nicolás Iriarte\n","date":"1 de enero de 1","img":"","lang":"es","langName":"Español","largeImg":"","permalink":"/es/about/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"About"},{"authors":[],"categories":[],"content":"Welcome to Bytewise!\nHey there! I\u0026rsquo;m Nicolás Iriarte, a passionate software developer and an enthusiastic student pursuing a Master\u0026rsquo;s degree in Embedded Systems. Currently, I\u0026rsquo;m thrilled to be part of the aerospace industry, working as a software engineer for INVAP, where we\u0026rsquo;re dedicated to developing cutting-edge software for spacecraft.\nAbout Me:\nCurrently I’m working as Technical Leader in the aerospace industry for INVAP. I\u0026rsquo;m also pursuing a Master\u0026rsquo;s in Embedded Systems, where I have been learning about Bare Metal (STM32 NUCLEO-F429ZI) and Processor Architecture (ARM Cortex-M4).\nRight now, I\u0026rsquo;m working on my degree project titled: \u0026ldquo;Leon3 Microprocessor Emulator for Satellite Software Development and Simulators\u0026rdquo;. In this project, I am developing an emulator for the Leon3 (GR712RC - Gaisler) microprocessor using the LLVM build tools framework. The development is being done in C++20, and it is intended that the developed emulator can be used in simulation environments such as SMP2 or similar.\nMy interests and skills are:\nFluency in C/C++. Python and Lua to a lesser extent. Programming in C for embedded systems. Continuous development. (CI/CD). English. Why This Blog:\nThrough this blog, I aim to share my experiences, insights, and knowledge in the world of software development and embedded systems. I believe that sharing knowledge not only helps others but also allows me to grow both as a developer and as an individual.\nWhat to Expect:\nOn this blog, you can look forward to a variety of topics related to software development, programming tips and tricks, in-depth discussions on C/C++ and Lua, and insights into the exciting realm of embedded systems. From tutorials to real-life projects, I\u0026rsquo;ll be covering it all!\nJoin Me on this Journey:\nI am eager to connect with like-minded developers, students, and enthusiasts who share a passion for technology and programming. Let\u0026rsquo;s learn from each other, exchange ideas, and foster a supportive community that thrives on curiosity and innovation.\nGet in Touch:\nFeel free to reach out to me via the comments section on each blog post or through my social media channels. I\u0026rsquo;m excited to engage with my readers and answer any questions you might have.\nThank you for stopping by! Let\u0026rsquo;s embark on this exciting adventure together.\nHappy coding! Nicolás Iriarte\n","date":"1 de enero de 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/about/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"About"},{"authors":[],"categories":[{"title":"C++ programming","url":"/es/categories/c++-programming/"}],"content":" En C++ constructores son un tipo de método especial de una clase, utilizado para inicializar dicha clase. En caso de que la clase no posea dicho método, el compilador normalmente dará uno por defecto, excepto en los siguientes casos:\nQue explicitamente se programe lo contrario. Que exista algun atributo en la clase que no sea construible por defecto. Que exista al menos otro constructor en la clase. El constructor de la clase se identifica ya que es un método in valor de retorno, y que tiene exactamente el mismo nombre que la clase.\nPor ejemplo:\nstruct Person { Person(std::string name, std::string last_name); }; En este ejemplo, se define la estructura Person, dicha estructura tiene un unico constructor, el cual recive dos argumentos del tipo std::string. Cabe aclarar que al definir un constructor para nuestra estructura, hemos eliminado el que nuestro compilador nos dá por defecto.\nLa implementación de nuestro constructor consta de dos partes:\nUna lista de inicialización, la cual es utilizada para asignar valor a atributos de la clase durante su creación, dicho código es ejecutado cuando la clase es creada. Implementación del constructor, generalmente utilizado para realizar validación de datos, o alguna lógica especial que se necesite realizar al crear nuevas instancias de dicho objeto. struct Person { Person(std::string name, std::string last_name) : // Comienzo de la lista de inicialización. name_(name), last_name_(last_name) { if (name.size() \u0026lt; 3) { throw std::runtime_error(\u0026#34;Nombre demasiado corto\u0026#34;); } } private: std::string name_; std::string last_name_; }; En el ejemplo provisto, utilizamos la lista de inicialización para asignar el nombre y apellido de la persona en la creación del objeto. Y dentro de la lógica del constructor, validamos que el nombre ingresado no sea menor de tres caracteres.\nCabe destacar que, aunque no se trate de un ejemplo muy realista o de uso cotidiano, refleja el funcionamiento y utilidad de un constructor.\n","date":"1 de enero de 1","img":"","lang":"es","langName":"Español","largeImg":"","permalink":"/es/docs/cpp/constructors/","series":[{"title":"C++","url":"/es/series/c++/"}],"smallImg":"","tags":[{"title":"C++","url":"/es/tags/c++/"},{"title":"Computer science","url":"/es/tags/computer-science/"},{"title":"Easy","url":"/es/tags/easy/"},{"title":"Basic knowledge","url":"/es/tags/basic-knowledge/"}],"timestamp":-62135596800,"title":"Constructores"},{"authors":[],"categories":[{"title":"C++ programming","url":"/categories/c++-programming/"}],"content":" In C++, constructors are a type of special method in a class, used to initialize that class. If the class does not have such a method, the compiler will usually provide a default one, except in the following cases:\nWhen it is explicitly programmed otherwise. When there is an attribute in the class that cannot be default-constructed. When there is at least one other constructor in the class. The class constructor is identified as a method without a return value and has exactly the same name as the class.\nFor example:\nstruct Person { Person(std::string name, std::string last_name); }; In this example, the Person struct is defined, and it has a single constructor that takes two arguments of type std::string. It\u0026#39;s important to note that by defining a constructor for our struct, we have overridden the default constructor provided by the compiler.\nThe implementation of our constructor consists of two parts:\nAn initialization list, which is used to assign values to class attributes during its creation. This code is executed when the class is being created. Implementation of the constructor itself, generally used to perform data validation or any special logic needed when creating new instances of the object. struct Person { Person(std::string name, std::string last_name) : // Start of the initialization list. name_(name), last_name_(last_name) { if (name.size() \u0026lt; 3) { throw std::runtime_error(\u0026#34;Name is too short\u0026#34;); } } private: std::string name_; std::string last_name_; }; In the provided example, we use the initialization list to assign the name and last name of the person during the object\u0026#39;s creation. And within the constructor\u0026#39;s logic, we validate that the entered name is not less than three characters long.\nIt\u0026#39;s worth noting that although this might not be a very realistic or everyday-use example, it reflects the functioning and usefulness of a constructor.\n","date":"1 de enero de 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/cpp/constructors/","series":[{"title":"C++","url":"/series/c++/"}],"smallImg":"","tags":[{"title":"C++","url":"/tags/c++/"},{"title":"Computer science","url":"/tags/computer-science/"},{"title":"Easy","url":"/tags/easy/"},{"title":"Basic knowledge","url":"/tags/basic-knowledge/"}],"timestamp":-62135596800,"title":"Constructors"},{"authors":[],"categories":[],"content":"","date":"1 de enero de 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/contact/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Contact Me"},{"authors":[],"categories":[],"content":"","date":"1 de enero de 1","img":"","lang":"es","langName":"Español","largeImg":"","permalink":"/es/contact/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Contactar"},{"authors":[],"categories":[],"content":"","date":"1 de enero de 1","img":"","lang":"es","langName":"Español","largeImg":"","permalink":"/es/offline/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"1 de enero de 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/offline/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Offline"},{"authors":[],"categories":[{"title":"C++ programming","url":"/es/categories/c++-programming/"}],"content":" Recientemente he arrancado mi carrera de posgrado, Carrera de Especialización en Sistemas Embebidos o (CESE para acortar). Para el segundo bimestre tocó seleccionar un tema de tesis, el cual está titulado como \u0026#34;Emulador de microprocesador Leon3 para desarrollo de Software satelital y simuladores\u0026#34;.\nPara productos de ámbitos espaciales, tales como satélites, muchas veces es difícil, y en ocasiones imposible, representar escenarios realistas para pruebas de los elementos que lo componen. Ya sea por no poder generar las mismas condiciones ambientales, o por que la naturaleza de la maniobra que se busca replicar implicaría un daño a los equipos bajo revisión. Bajo este contexto, es común replicar susodichos elementos de manera programada, es decir, desarrollar los elementos con cierto grado de representación para que se comporten de la manera más representativa posible a su contraparte física. Dichos elementos se los llaman emulados o simulados. Uno de los componentes que se suele tener mayor interés en simular es el procesador de la computadora a bordo, el cúal se monta sobre el satélite real y ejecuta el software de vuelo.\nCabe destacar, que hoy en día existen emuladores tanto open-source como privativos para distintos procesadores. Un ejemplo claro de emulador open-source es Qemu, el cual abarca un amplio abanico de microprocesadores, entre ellos, algunos que se pueden utilizar en el ámbito espacial.\nCada caso de emulador, aunque solucionan el problema en cuestión, viene con sus respectivas desventajas. Por ejemplo, los emuladores open-source suelen divergir para ampliar el rango de procesadores soportados, generalmente disminuyendo su performance. Por otro lado, los emuladores privativos al no tener acceso al código muchas veces se vuelven difíciles de integrar, ya que no se tiene un conocimiento exacto sobre las limitaciones del mismo, y en general, difíciles de depurar el software que ejecutan.\nBajo estas premisas se plantea crear un emulador de microprocesador Leon3 para desarrollo de software satelital y simuladores. Al ser un desarrollo a medida, se tendrá la ventaja de la no-diversificación del procesador, es decir, estará únicamente orientado a un solo microprocesador. Esperando una ganancia en performance comparado con su contraparte open-source. Al mismo tiempo, se tendrá un conocimiento extenso del alcance y limitaciones de las capacidades del software en cuestión. Haciendo de esta manera, más simple la integración y depuración en su uso.\n","date":"1 de enero de 1","img":"","lang":"es","langName":"Español","largeImg":"","permalink":"/es/news/1/01/presentaci%C3%B3n-de-tesis/","series":[{"title":"Thesis","url":"/es/series/thesis/"}],"smallImg":"","tags":[{"title":"C++","url":"/es/tags/c++/"},{"title":"Computer science","url":"/es/tags/computer-science/"},{"title":"LLVM","url":"/es/tags/llvm/"}],"timestamp":-62135596800,"title":"Presentación De Tesis"},{"authors":[],"categories":[{"title":"C++ programming","url":"/es/categories/c++-programming/"}],"content":" RAII del inglés \u0026#34;Resource Acquisition Is Initialization\u0026#34; es una técnica de C++ para manejar el ciclo de vida de recursos típicamente limitados (memoria en el heap, descriptores de archivos, hilos de ejecución, etc).\nDicha técnica consiste en reservar el recurso durante el constructor del objeto, y su liberación en el destructor. Por ejemplo, imaginemos que se desea modelar una memoria Flash de tamaño variable, para ello, una posibilidad sería la de reservar memoria del heap en su construcción, para liberarla durante su destrucción:\nstruct FlashMemory { FlashMemory(uint32_t size) { memory_ = new uint8_t[size]; } ~FlashMemory() { delete[] memory_; } private: uint8_t *memory_; }; RAII garantiza que mientras el objeto esté instanciado, el recurso será accesible, y define un ciclo de vida del mismo acoplado al ciclo de vida del objeto que lo contiene. Esto facilita su manejo manual y libera al desarrollador que lo utilice de asignaciones manuales de memoria o del recurso.\nEs conveniente que el objeto que maneje al recurso, en nuestro caso FlashMemory tenga métodos expuestos para accederlo, por ejemplo, en nuestro caso, métodos para leer/escribir la memoria.\nstruct FlashMemory { FlashMemory(uint32_t size) : size_(size) { memory_ = new uint8_t[size]; } ~FlashMemory() { delete[] memory_; } /** ,* Lee un Byte de memoria, si se trata de acceder fuera de la memoria se ,* arroja una excepción. ,*/ uint8_t ReadByte(uint32_t position) const { if (position \u0026gt;= size_) { throw std::runtime_error(\u0026#34;Invalid position to Read!\u0026#34;); } return memory_[position]; } /** ,* Escribe un Byte de memoria, si se trata de acceder fuera de la memoria se ,* arroja una excepción. ,*/ void WriteByte(uint32_t position, uint8_t value) { if (position \u0026gt;= size_) { throw std::runtime_error(\u0026#34;Invalid position to Write!\u0026#34;); } memory_[position] = value; } private: uint8_t *memory_; uint32_t size_; }; De esta manera se puede manejar al objeto y su tiempo de vida de manera transparente para el usuario.\nstatic constexpr uint32_t MEMORY_SIZE = 256 * 1024; int main(int argc, char *argv[]) { // Esta linea reserva de manera invisible al usuario memoria en el heap. FlashMemory flash(MEMORY_SIZE); // En el byte 0x64 ponemos el valor 0x23 flash.WriteByte(0x64, 0x23); std::cout \u0026lt;\u0026lt; \u0026#34;La posición 0x64 contiene el valor: \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(flash.ReadByte(0x64)) \u0026lt;\u0026lt; std::endl; return 0; // En este punto el destructor de `FlashMemory` es llamado, y todos // sus recursos liberados de manera automatica. } ","date":"1 de enero de 1","img":"","lang":"es","langName":"Español","largeImg":"","permalink":"/es/docs/cpp/raii/","series":[{"title":"C++","url":"/es/series/c++/"}],"smallImg":"","tags":[{"title":"C++","url":"/es/tags/c++/"},{"title":"Computer science","url":"/es/tags/computer-science/"},{"title":"Easy","url":"/es/tags/easy/"},{"title":"Basic knowledge","url":"/es/tags/basic-knowledge/"}],"timestamp":-62135596800,"title":"RAII"},{"authors":[],"categories":[{"title":"C++ programming","url":"/categories/c++-programming/"}],"content":" RAII, which stands for \u0026#34;Resource Acquisition Is Initialization,\u0026#34; is a C++ technique for managing the lifecycle of typically limited resources (such as heap memory, file descriptors, threads, etc.).\nThis technique involves reserving the resource during the object\u0026#39;s constructor and releasing it in the destructor. For example, let\u0026#39;s imagine you want to model a variable-sized Flash memory. One possibility would be to allocate memory from the heap during its construction and free it during its destruction:\nstruct FlashMemory { FlashMemory(uint32_t size) { memory_ = new uint8_t[size]; } ~FlashMemory() { delete[] memory_; } private: uint8_t *memory_; }; RAII guarantees that as long as the object is instantiated, the resource will be accessible, and it defines a lifecycle for the resource that is tied to the lifecycle of the containing object. This simplifies manual management and relieves the developer from manual memory allocations or resource handling.\nIt\u0026#39;s advisable for the object that manages the resource, in this case FlashMemory, to have exposed methods for accessing it. For instance, in our case, methods to read/write the memory:\nstruct FlashMemory { FlashMemory(uint32_t size) : size_(size) { memory_ = new uint8_t[size]; } ~FlashMemory() { delete[] memory_; } /** ,* Reads a byte from memory. Throws an exception if an invalid position is ,* accessed. ,*/ uint8_t ReadByte(uint32_t position) const { if (position \u0026gt;= size_) { throw std::runtime_error(\u0026#34;Invalid position to Read!\u0026#34;); } return memory_[position]; } /** ,* Writes a byte to memory. Throws an exception if an invalid position is ,* accessed. ,*/ void WriteByte(uint32_t position, uint8_t value) { if (position \u0026gt;= size_) { throw std::runtime_error(\u0026#34;Invalid position to Write!\u0026#34;); } memory_[position] = value; } private: uint8_t *memory_; uint32_t size_; }; This way, the object and its lifetime can be managed transparently for the user.\nstatic constexpr uint32_t MEMORY_SIZE = 256 * 1024; int main(int argc, char *argv[]) { // This line invisibly allocates memory on the heap for the user. FlashMemory flash(MEMORY_SIZE); // Set the value 0x23 at byte 0x64 flash.WriteByte(0x64, 0x23); std::cout \u0026lt;\u0026lt; \u0026#34;The value at position 0x64 is: \u0026#34; \u0026lt;\u0026lt; static_cast\u0026lt;int\u0026gt;(flash.ReadByte(0x64)) \u0026lt;\u0026lt; std::endl; return 0; // At this point, the destructor of `FlashMemory` is called, and all // its resources are automatically freed. } ","date":"1 de enero de 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/docs/cpp/raii/","series":[{"title":"C++","url":"/series/c++/"}],"smallImg":"","tags":[{"title":"C++","url":"/tags/c++/"},{"title":"Computer science","url":"/tags/computer-science/"},{"title":"Easy","url":"/tags/easy/"},{"title":"Basic knowledge","url":"/tags/basic-knowledge/"}],"timestamp":-62135596800,"title":"RAII"},{"authors":[],"categories":[{"title":"C++ programming","url":"/categories/c++-programming/"}],"content":" Recently, I have started my postgraduate studies in the \u0026#34;Specialization in Embedded Systems\u0026#34; program, abbreviated as CESE. For the second semester, I had to select a thesis topic, which is titled \u0026#34;Emulator of Leon3 Microprocessor for Satellite Software Development and Simulators.\u0026#34;\nIn the realm of space products, such as satellites, it is often difficult, and at times impossible, to recreate realistic scenarios for testing the components that constitute them. This could be due to the inability to replicate the same environmental conditions, or because attempting to replicate the intended maneuver could potentially damage the equipment under review. In such contexts, it is common to simulate these elements programmatically—that is, to develop elements with a certain degree of representation so that they behave as realistically as possible compared to their physical counterparts. These simulated elements are often referred to as emulated or simulated. One of the components that is of significant interest to simulate is the onboard computer processor, which is mounted on the actual satellite and runs the flight software.\nIt\u0026#39;s worth noting that there are both open-source and proprietary emulators available for various processors today. An evident example of an open-source emulator is Qemu, which covers a wide range of microprocessors, including some that can be used in the space domain.\nWhile each emulator addresses the problem at hand, they come with their respective drawbacks. For instance, open-source emulators tend to diverge in order to broaden the range of supported processors, which often results in decreased performance. On the other hand, proprietary emulators, due to their lack of access to the source code, can be challenging to integrate as there is limited knowledge about their limitations, and debugging the software they execute can be difficult.\nWith these premises in mind, the idea is to develop an emulator for the Leon3 microprocessor specifically designed for satellite software development and simulators. Since this is a custom development, there will be an advantage in terms of processor specialization, focusing solely on a single microprocessor. This is expected to result in improved performance compared to open-source alternatives. Additionally, there will be an extensive understanding of the scope and limitations of the software\u0026#39;s capabilities. This, in turn, will simplify the integration and debugging processes in its usage.\n","date":"1 de enero de 1","img":"","lang":"en","langName":"English","largeImg":"","permalink":"/news/1/01/thesis-presentation/","series":[{"title":"Thesis","url":"/series/thesis/"}],"smallImg":"","tags":[{"title":"C++","url":"/tags/c++/"},{"title":"Computer science","url":"/tags/computer-science/"},{"title":"LLVM","url":"/tags/llvm/"}],"timestamp":-62135596800,"title":"Thesis Presentation"}]
